---
date: 2024-06-18
order: 3
---

# 第三章：设计计算机硬件

## 1.实现一个ALU

**ALU（算术逻辑单元）是计算机中的一种关键组件，负责执行算术运算和逻辑运算。它是中央处理器（CPU）内部的一个重要功能模块，用于处理数据和执行指令。简单的ALU，可以看作是计算电路的大杂烩，例如，接下来我们打算实现一个ALU，它能够实现A、B两个16bit数字之间的加法、减法、按位与和按位或运算，同时有一个ZF（Zero Flag）指示A、B两数是否相等**

![](./assert/3.设计计算机硬件/选择器.png)
![](./assert/3.设计计算机硬件/16位ALU实现.png)

---

## 2.实现一个简单的计算单元

![](./assert/3.设计计算机硬件/计算单元1.png)
![](./assert/3.设计计算机硬件/计算单元2.png)

---

## 3.添加一块数据存储

**刚刚的这个累加过程，我们完全是通过手动操作进行的。而现实情况是，我们的计算一般都是通过预设的程序自动完成。而预设的程序，需要一个外部存储。对于一般的个人计算机来说，这个存储是内存和硬盘，但是此时我们为了简化计算机的外部架构，专注于CPU内部设计，我们就统一只使用一种外部存储，一块由多个16bit寄存器组成的内存**

---

### 3.1 用寄存器实现一块内存

![](./assert/3.设计计算机硬件/寄存器实现一块内存.png)
![](./assert/3.设计计算机硬件/寄存器实现一块内存2.png)
![](./assert/3.设计计算机硬件/寄存器实现一块内存3.png)
![](./assert/3.设计计算机硬件/寄存器实现一块内存4.png)

---

### 3.2 给计算单元接入外部存储

**对我们之前的计算单元做一点小小的改造，我们添加一块EEPROM，将数据位数设置为16，地址位数设置为2，并将我们刚刚的四个数写到这块存储中。如下图所示**

![](./assert/3.设计计算机硬件/接入外部存储.png)
![](./assert/3.设计计算机硬件/接入外部存储2.png)
![](./assert/3.设计计算机硬件/接入外部存储3.png)
![](./assert/3.设计计算机硬件/接入外部存储4.png)

---

## 4.添加一块指令存储

**目前我们的程序只能计算四个数的加法，那如果我们想计算13+45-27-6呢？毕竟我们的ALU是支持减法运算的。这时候我们就要一段输入信号去控制ALU的sel输入**

**我们加入一块新的EEPROM，将数据设置为16bit，地址设置为2bit，并输入数据0、0、1、1，对应ALU的加法、加法、减法、减法。将EEPROM的输出连接到ALU的sel，这中间注意做位数转换**

**将这块EEPROM的时钟信号和Clock相连，Din，str，ld的处理与数据RAM一样。地址位也连上计数器输出，最终效果如图所示：**

![](./assert/3.设计计算机硬件/添加一块指令存储.png)
![](./assert/3.设计计算机硬件/添加一块指令存储2.png)

---

## 5.添加其他控制指令

### 5.1 添加halt信号位

![](./assert/3.设计计算机硬件/添加halt信号位.png)
![](./assert/3.设计计算机硬件/添加halt信号位2.png)

---

### 5.2 添加str存储信号位

![](./assert/3.设计计算机硬件/添加str存储信号位.png)
![](./assert/3.设计计算机硬件/添加str存储信号位2.png)
![](./assert/3.设计计算机硬件/添加str存储信号位3.png)

---

### 5.3 添加ld数据RAM输入信号、selB数据选择信号

![](./assert/3.设计计算机硬件/添加Id信号.png)
![](./assert/3.设计计算机硬件/添加Id信号2.png)
![](./assert/3.设计计算机硬件/添加Id信号3.png)
![](./assert/3.设计计算机硬件/添加Id信号4.png)

---

### 5.4 添加enA、selA信号

**我们又有了一个新的需求，希望连续计算两个表达式的值。比如：13+45-27=31的结果存放在地址3处和（15|8）&23 = 7的结果存放在地址7处。那么我们可以分别向数据RAM和地址RAM中输入如下数据：**

![](./assert/3.设计计算机硬件/添加enA信号.png)
![](./assert/3.设计计算机硬件/添加enA信号2.png)
![](./assert/3.设计计算机硬件/添加enA信号3.png)
![](./assert/3.设计计算机硬件/添加enA信号4.png)

---

### 5.5 添加jmp跳转信号

**通过上面的学习，我们应该已经有了一种意识，我们通过控制指令RAM中的指令的0、1状态，去控制电路中的对应开关，来实现对应的功能。我们要实现一种运算，只需要在指令RAM填好指令，在数据RAM中填好要操作的数据，那么电路就会根据开关指令去操作数据得到结果**

![](./assert/3.设计计算机硬件/添加jmp跳转信号.png)
![](./assert/3.设计计算机硬件/添加jmp跳转信号2.png)
![](./assert/3.设计计算机硬件/添加jmp跳转信号3.png)
![](./assert/3.设计计算机硬件/添加jmp跳转信号4.png)
![](./assert/3.设计计算机硬件/添加jmp跳转信号5.png)

**因此，我们需要在跳转时不让数据RAM输出的跳转地址进入寄存器A，因此需要增加一个控制信号enA，来控制A寄存器的输入使能**

**添加enA指令后的信号控制位及指令如图：**

![](./assert/3.设计计算机硬件/添加jmp跳转信号6.png)
![](./assert/3.设计计算机硬件/添加jmp跳转信号7.png)

---

### 5.6 添加je条件跳转信号

**jmp跳转是无条件的跳转，程序流程控制也需要有条件的跳转，什么是有条件的跳转呢？比如：如果年龄=18，可以参加活动！所以，最常见的条件就是比较两个数的大小。如果相等就执行相应的操作。我们的ALU在设计阶段就已经实现了比较的功能。如图：**

![](./assert/3.设计计算机硬件/添加je条件跳转信号.png)
![](./assert/3.设计计算机硬件/添加je条件跳转信号2.png)
![](./assert/3.设计计算机硬件/添加je条件跳转信号3.png)

---

## 6.添加控制器

![](./assert/3.设计计算机硬件/添加控制器.png)
![](./assert/3.设计计算机硬件/添加控制器2.png)
![](./assert/3.设计计算机硬件/添加控制器3.png)
![](./assert/3.设计计算机硬件/添加控制器4.png)
![](./assert/3.设计计算机硬件/添加控制器5.png)

---

## 7.将两块内存合二为一

### 7.1 现有系统运行方式梳理

**在合并改造之前，我们先回顾一下我们现在的系统**

- **开始我们有一个PC程序计数器，程序计数器的输出是一个4位的地址**
- **该4位的地址既是我们指令RAM的地址，用来获取指令RAM中存放的opcode，也是数据RAM的读取地址，用来读取数据RAM中存放的数据**
- **接下来我们的opcode通过控制器中的查找表，会映射出整个电路的信号开关控制情况，进而实现相应的功能**
- **不同的指令会对数据RAM中读取的数据进行不同的操作**
- **数据RAM的输出有两个作用：①作为数据输出，②当执行jmp或je的时候，作为要跳转的地址**
- **比较寄存器存储A、B输入比较的结果，如果相同存储1，不同存储0，该比较结果用来做为je跳转的依据。以上就是我们当前系统的相关功能**

---

### 7.2 现有系统的指令

![](./assert/3.设计计算机硬件/现有系统的指令.png)

---

### 7.3 操作数和操作码

**将两个RAM合并为一个RAM之前，我们先介绍一种数据存储的方式，操作码+操作数**

**现在我们的系统计算一个算式：13+45-27时，数据RAM和指令RAM中的数据存储情况如下：**

![](./assert/3.设计计算机硬件/操作数和操作码.png)
![](./assert/3.设计计算机硬件/操作数和操作码2.png)

**我们合并成一个RAM之后，RAM中存储指令的方式就是操作码+操作数的方式。这里介绍了这种方式，方便后面的理解。那么接下来就让我们来合并RAM吧**

---

### 7.4 合并为一个RAM

![](./assert/3.设计计算机硬件/合并为一个RAM.png)

---

### 7.5.取指令和执行指令

**既然一个时钟周期做不到，那么我们就将程序的执行分成两个时钟周期来完成一个任务。第一个时钟周期用于读取指令。第二个时钟周期用于读取数据并执行指令**

**取址阶段：在这个阶段，RAM的地址信号是指令的地址。RAM输出的是指令**

**执行阶段：在这个阶段，RAM的地址信号是数据的地址。RAM输出的是数据。也是在这个阶段去执行上一个时钟周期读取到的指令。因为执行指令阶段需要获取到上一个时钟周期的指令，因此，需要有一个指令寄存器去存储上一个时钟周期获取的指令**

![](./assert/3.设计计算机硬件/取指令和执行指令.png)

---

### 7.6 电路实现

![](./assert/3.设计计算机硬件/电路实现.png)
![](./assert/3.设计计算机硬件/电路实现2.png)

**<font color=red>(1)创建RAM、指令寄存器</font>**

![](./assert/3.设计计算机硬件/创建RAM.png)

**<font color=red>(2)RAM的数据结构</font>**

**将数据RAM和地址RAM合并成一块RAM，那么就要求新的RAM中既有指令又有数据。此处以4条指令和4条数据为例。我们将前4条指令储存在内存的前4个地址，将4条数据存储在内存的后4个地址。要计算19+69-27的结果，并要将结果存放在地址7的位置**

![](./assert/3.设计计算机硬件/RAM数据结构.png)

**<font color=red>(3)修改PC计数器的地址位为11位</font>**

**指令寄存器输出的内容为opcode和addr，addr是11位的。addr又会作为PC计数器的输入，我们的PC计数器原来的地址位是4位的，因此要将PC计数器整体修改为11位**

**同时，PC计数器输出的A地址也会变为11位，A地址又作为RAM的地址输入，因此RAM的地址位也要改为11位**

**如果改为11位之后，前面用到PC计数器的电路都是4位的将不能使用。因此，我们需要将PC计数器做成通用组件**

![](./assert/3.设计计算机硬件/修改PC计数器.png)
![](./assert/3.设计计算机硬件/修改PC计数器2.png)
![](./assert/3.设计计算机硬件/修改PC计数器3.png)

**<font color=red>(4)修改RAM的地址位为11位</font>**

![](./assert/3.设计计算机硬件/修改RAM地址位.png)

**<font color=red>(5)控制器改造</font>**

![](./assert/3.设计计算机硬件/控制器改造.png)
![](./assert/3.设计计算机硬件/控制器改造2.png)
![](./assert/3.设计计算机硬件/控制器改造3.png)

**<font color=red>(6)最终电路图</font>**

![](./assert/3.设计计算机硬件/最终电路图.png)
![](./assert/3.设计计算机硬件/最终电路图2.png)

**<font color=red>(7)执行过程演示</font>**

**现在我们要用两个时钟周期完成，第一个时钟周期获取指令，第二个时钟周期执行指令。所以我们的计数器要两个周期再递增**

![](./assert/3.设计计算机硬件/执行过程演示.png)

---

## 8.添加立即数

**现有系统的数据RAM存储方式（操作码+操作数）**

![](./assert/3.设计计算机硬件/添加立即数.png)

---

### 8.1 添加立即数后的指令

![](./assert/3.设计计算机硬件/添加立即数后的指令.png)

---

### 8.2 电路改造

![](./assert/3.设计计算机硬件/电路改造.png)
![](./assert/3.设计计算机硬件/电路改造2.png)

---

### 8.3 控制器改造

![](./assert/3.设计计算机硬件/立即数控制器改造.png)
![](./assert/3.设计计算机硬件/立即数控制器改造2.png)

---

### 8.4 测试立即数功能

![](./assert/3.设计计算机硬件/测试立即数.png)

---

## 9.添加B寄存器

**目前我们只有一个寄存器A，寄存器相当于是编程中的一个变量，也就是我们现在的系统只支持一个变量的运算。如果我们需要进行多个变量的运算，一个寄存器是不够的。因此，我们需要为系统再添加一个寄存器B**

---

### 9.1 电路改造

![](./assert/3.设计计算机硬件/添加B寄存器电路改造.png)
![](./assert/3.设计计算机硬件/添加B寄存器电路改造2.png)

---

### 9.2 指令集

**指令集，就是你希望CPU能够完成的操作。现在流行的指令集有x86,arm和risc-V。前两个指令集都是有知识产权的，不能随便用，而risc-V是开源指令集。指令集不光是随便设计一套指令就可的，最重要的是上下游的生态环境。比如同学们之前学过的C语言，在编译过程中，gcc工具链可以将C语言完整编译成x86指令，gcc-eabi工具链可以编译arm指令，risc-V也有对应的工具链，但是其上下游其他配套设施无法与前两者相提并论**

**无论是x86，arm，还是risc-V指令集，对于我们设计的这个基础CPU都过于复杂，所以我们接下来会自己设计一套指令集，相对的，我们就没有配套的编译器为我们完成编译工作，接下来的编译工作我们只能自己手动进行。我们的指令集支持无符号16位数的加、减、按位与、按位或，支持基于等值的循环和分支控制，支持立即数对寄存器的运算**

![](./assert/3.设计计算机硬件/指令集.png)

---

### 9.3 更新控制器查找表

![](./assert/3.设计计算机硬件/更新控制器查找表.png)

---

### 9.4 测试

![](./assert/3.设计计算机硬件/测试.png)